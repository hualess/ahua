{
  "msg": "success",
  "code": 200,
  "article": {
    "id": 5,
    "title": "性能分析利器《Arthas》总结",
    "description": "Arthas 是Alibaba开源的Java诊断工具，为什么要介绍这个工具呢？先来看看你是否都遇到这样的场景：当你线上项目出了问题，但是一打开日志发现，有些地方忘记打了日志，于是你马上补上日志，然后重新上线。当你的项目某个接口执行速度较慢，为了排查问题，于是你四处加上每个方法运行时间。当你发现某个类有冲突，好像在线上运行的结果和你预期的不符合，手动把线上编译出的class文件下载下来然后反编译，看看究竟class内容是什么。",
    "author": "Bobbi",
    "content": "## 性能分析利器《Arthas》总结\r\nArthas 是Alibaba开源的Java诊断工具，为什么要介绍这个工具呢？先来看看你是否都遇到这样的场景：\r\n\r\n- 当你线上项目出了问题，但是一打开日志发现，有些地方忘记打了日志，于是你马上补上日志，然后重新上线。\r\n- 当你的项目某个接口执行速度较慢，为了排查问题，于是你四处加上每个方法运行时间。\r\n- 当你发现某个类有冲突，好像在线上运行的结果和你预期的不符合，手动把线上编译出的class文件下载下来然后反编译，看看究竟class内容是什么。\r\n- 当你发现系统突然报出某个类的Exception，却无法找到这个类是从哪个Jar包加载的。\r\n- 当你发现有时候排查一个问题需要上游重复调用这个方法，于是你只能想尽办法利用postman等工具重现这个请求。\r\n\r\n\r\n下面我将会介绍一下Arthas的一些常用的命令和用法，看看是如何解决我们实际中的问题的，至于安装教程可以参考Arthas的github。\r\n> https://github.com/alibaba/arthas\r\n\r\n## 常用命令\r\ndashboard 当前系统的实时数据面板  \r\n\r\njvm 查看当前JVM信息  \r\n\r\nthread 可直接查看线程的cpu占用比  \r\n\r\nsc sm 快速搜索类和方法信息  \r\n\r\ngetstatic 查看类静态变量  \r\n\r\njad 反编译class文件  \r\n\r\nmc 编译.java文件生成.class  \r\n\r\nredefine 加载外部class文件到应用程序中  \r\n\r\nmonitor 监测方法调用次数、成功次数、失败次数、平均RT等  \r\n\r\nwatch tt 观测方法执行的前、后、结束、异常、耗时过大时，入参（入参属性深度可调）、返回值、异常，支持实时监测每次方法执行和方法的所有调用执行。  \r\n\r\ntrace 查看方法调用树耗时  \r\n\r\nstack 查看方法的所有调用树路径\r\n\r\n## 1.奇怪的类加载错误\r\n&emsp;&emsp;相信大家都遇到过NoSuchMethodError这个错误，一般老司机看见这个错误第一反应就是jar包版本号冲突，这种问题一般来说使用maven的一些插件就能轻松解决。  \r\n\r\n&emsp;&emsp;之前遇到个奇怪的问题，我们有两个服务的client-jar包，有个类的包名和类名均是一致，在编写代码的时候没有注意到这个问题，在编译阶段由于包名和类名都是一致，所有编译阶段并没有报错，在线下的运行阶段没有问题，但是测试环境的机器中的运行阶段缺报出了问题。这个和之前的jar包版本号冲突有点不同，因为在排查的时候我们想使用A服务的client-jar包的这个类，但是这个jar包的版本号在Maven中的确是唯一的。\r\n这个时候Arthas就可以大显神通了。\r\n### 1.1 sc命令\r\n找到对应的类，然后输出下面的命令(用例使用的是官方提供的用例):\r\n``` shell\r\n$ sc -d demo.MathGame\r\nclass-info        demo.MathGame\r\ncode-source       /private/tmp/arthas-demo.jar\r\nname              demo.MathGame\r\nisInterface       false\r\nisAnnotation      false\r\nisEnum            false\r\nisAnonymousClass  false\r\nisArray           false\r\nisLocalClass      false\r\nisMemberClass     false\r\nisPrimitive       false\r\nisSynthetic       false\r\nsimple-name       MathGame\r\nmodifier          public\r\nannotation\r\ninterfaces\r\nsuper-class       +-java.lang.Object\r\nclass-loader      +-sun.misc.Launcher$AppClassLoader@3d4eac69\r\n                    +-sun.misc.Launcher$ExtClassLoader@66350f69\r\nclassLoaderHash   3d4eac69\r\n \r\nAffect(row-cnt:1) cost in 875 ms.\r\n\r\n```\r\n可以看见打印出了code-source,当时发现了code-source并不是从对应的Jar包取出来的，于是发现了两个服务对于同一个类使用了同样的包名和类名，导致了这个奇怪的问题，后续通过修改包名和类名进行解决。\r\n\r\n### 1.2 jad\r\nArthas还提供了一个命令jad用来反编译,对于解决类冲突错误很有用，比如我们想知道这个类里面的代码到底是什么，直接一个jad命令就能搞定:\r\n```shell\r\n$ jad java.lang.String\r\n \r\nClassLoader:\r\n \r\nLocation:\r\n \r\n/*\r\n* Decompiled with CFR 0_132.\r\n*/\r\npackage java.lang;\r\n \r\nimport java.io.ObjectStreamField;\r\n...\r\npublic final class String\r\nimplements Serializable,\r\nComparable<String>,\r\nCharSequence {\r\n    private final char[] value;\r\n    private int hash;\r\n    private static final long serialVersionUID = -6849794470754667710L;\r\n    private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];\r\n    public static final Comparator<String> CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator();\r\n \r\n    public String(byte[] arrby, int n, int n2) {\r\n        String.checkBounds(arrby, n, n2);\r\n        this.value = StringCoding.decode(arrby, n, n2);\r\n    }\r\n...\r\n```\r\n\r\n一般通过这个命令我们就能发现和你所期待的类是否缺少了某些方法，或者某些方法有些改变，从而确定jar包冲突。\r\n\r\n## 2.动态修改日志级别\r\n有很多同学可能会觉得动态修改日志有什么用呢？好像自己也没怎么用过呢？\r\n一般来说下面这几个场景可以需要:  \r\n\r\n一般大家日志级别默认是info，有时候需要查看debug的日志可能需要重新上线。\r\n当线上某个应用流量比较大的时候，如何业务出现问题，可能会短时间之内产生大量日志，由于日志会写盘，会消耗大量的内存和磁盘IO进一步加重我们的问题严重性，进而引起雪崩。\r\n我们可以使用动态修改日志解决我们上面两个问题\r\n\r\n### 2.1 ognl\r\nognl是一门表达式语言，在Arthas中你可以利用这个表达式语言做很多事，比如执行某个方法，获取某个信息。再这里我们可以通过下面的命令来动态的修改日志级别:\r\n``` shell\r\n$ ognl '@com.lz.test@LOGGER.logger.privateConfig'\r\n@PrivateConfig[\r\n    loggerConfig=@LoggerConfig[root],\r\n    loggerConfigLevel=@Level[INFO],\r\n    intLevel=@Integer[400],\r\n]\r\n$ ognl '@com.lz.test@LOGGER.logger.setLevel(@org.apache.logging.log4j.Level@ERROR)'\r\nnull\r\n$ ognl '@com.lz.test@LOGGER.logger.privateConfig'\r\n@PrivateConfig[\r\n    loggerConfig=@LoggerConfig[root],\r\n    loggerConfigLevel=@Level[ERROR],\r\n    intLevel=@Integer[200],\r\n  \r\n]\r\n\r\n```\r\n\r\n\r\n## 3.如何知道某个方法是否调用\r\n很多时候我们方法执行的情况和我们预期不符合，但是我们又不知道到底哪里不符合，Arthas的watch命令就能帮助我们解决这个问题。\r\n\r\n### 3.1 watch\r\nwatch命令顾名思义观察，他可以观察指定方法调用情况，定义了4个观察事件点， -b 方法调用前，-e 方法异常后，-s 方法返回后，-f 方法结束后。默认是-f\r\n比如我们想知道某个方法执行的时候，参数和返回值到底是什么。注意这里的参数是方法执行完成的时候的参数，和入参不同有可能会发生变化。\r\n``` shell\r\n$ watch demo.MathGame primeFactors \"{params,returnObj}\" -x 2\r\nPress Ctrl+C to abort.\r\nAffect(class-cnt:1 , method-cnt:1) cost in 44 ms.\r\nts=2018-12-03 19:16:51; [cost=1.280502ms] result=@ArrayList[\r\n    @Object[][\r\n        @Integer[535629513],\r\n    ],\r\n    @ArrayList[\r\n        @Integer[3],\r\n        @Integer[19],\r\n        @Integer[191],\r\n        @Integer[49199],\r\n    ],\r\n]\r\n```\r\n\r\n你能得到参数和返回值的情况，以及方法时间消耗的等信息。\r\n\r\n## 4.如何知道某个方法耗时较多\r\n当某个方法耗时较长，这个时候你需要排查到底是某一处发生了长时间的耗时，一般这种问题比较难排查，都是通过全链路追踪trace图去进行排查，但是在本地的应用中没有trace图，这个时候需要Arthas的trace命令来进行排查问题。\r\n### 4.1 trace\r\ntrace 命令能主动搜索 class-pattern／method-pattern 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。\r\n但是trace只能追踪一层的调用链路，如果一层的链路信息不够用，可以把该链路上有问题的方法再次进行trace。\r\ntrace使用例子如下。\r\n``` shell\r\n$ trace demo.MathGame run\r\nPress Ctrl+C to abort.\r\nAffect(class-cnt:1 , method-cnt:1) cost in 42 ms.\r\n`---ts=2018-12-04 00:44:17;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69\r\n    `---[10.611029ms] demo.MathGame:run()\r\n        +---[0.05638ms] java.util.Random:nextInt()\r\n        +---[10.036885ms] demo.MathGame:primeFactors()\r\n        `---[0.170316ms] demo.MathGame:print()\r\n\r\n```\r\n\r\n可以看见上述耗时最多的方法是primeFactors，所以我们可以对其进行trace进行再一步的排查。\r\n\r\n## 5.如何使用命令重发请求？\r\n有时候排查一个问题需要上游再次调用这个方法，比如使用postMan等工具，当然Arthas提供了一个命令让替代我们来回手动请求。\r\n### 5.1 tt\r\ntt官方介绍: 方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测。可以看见tt可以用于录制请求，当然也支持我们重放。\r\n如果要录制某个方法，可以用下面命令:\r\n```shell\r\n$ tt -t demo.MathGame primeFactors\r\nPress Ctrl+C to abort.\r\nAffect(class-cnt:1 , method-cnt:1) cost in 66 ms.\r\n INDEX   TIMESTAMP            COST(ms)  IS-RET  IS-EXP   OBJECT         CLASS                          METHOD\r\n-------------------------------------------------------------------------------------------------------------------------------------\r\n 1000    2018-12-04 11:15:38  1.096236  false   true     0x4b67cf4d     MathGame                       primeFactors\r\n 1001    2018-12-04 11:15:39  0.191848  false   true     0x4b67cf4d     MathGame                       primeFactors\r\n 1002    2018-12-04 11:15:40  0.069523  false   true     0x4b67cf4d     MathGame                       primeFactors\r\n 1003    2018-12-04 11:15:41  0.186073  false   true     0x4b67cf4d     MathGame                       primeFactors\r\n 1004    2018-12-04 11:15:42  17.76437  true    false    0x4b67cf4d     MathGame                       primeFactors\r\n\r\n```\r\n\r\n上面录制了5个调用环境现场，也可以看做是录制了5个请求返回信息。比如我们想选择index为1004个的请求来重放，可以输入下面的命令。\r\n```shell\r\n$ tt -i 1004 -p\r\n RE-INDEX       1004\r\n GMT-REPLAY     2018-12-04 11:26:00\r\n OBJECT         0x4b67cf4d\r\n CLASS          demo.MathGame\r\n METHOD         primeFactors\r\n PARAMETERS[0]  @Integer[946738738]\r\n IS-RETURN      true\r\n IS-EXCEPTION   false\r\n RETURN-OBJ     @ArrayList[\r\n                    @Integer[2],\r\n                    @Integer[11],\r\n                    @Integer[17],\r\n                    @Integer[2531387],\r\n                ]\r\nTime fragment[1004] successfully replayed.\r\nAffect(row-cnt:1) cost in 14 ms.\r\n```\r\n\r\n注意重放请求需要关注两点:\r\n\r\nThreadLocal 信息丢失:由于使用的是Arthas线程调用，会让threadLocal信息丢失，比如一些TraceId信息可能会丢失\r\n引用的对象:保存的入参是保存的引用，而不是拷贝，所以如果参数中的内容被修改，那么入参其实也是被修改的。\r\n\r\n## 6.一些耗时的方法，经常被触发，如何知道谁调用的?\r\n有时候有些方法非常耗时或者非常重要，需要知道到底是谁发起的调用，比如System.gc(),有时候如果你发现fullgc频繁是因为System.gc()引起的，你需要查看到底是什么应用调用的，那么你就可以使用下面的命令\r\n我们可以输入下面的命令:\r\n```shell\r\n$ options unsafe true\r\n NAME    BEFORE-VALUE  AFTER-VALUE                                                                                                                                                                        \r\n-----------------------------------                                                                                                                                                                       \r\n unsafe  false         true                                                                                                                                                                               \r\n$ stack java.lang.System gc\r\nPress Ctrl+C to abort.\r\nAffect(class-cnt:1 , method-cnt:1) cost in 50 ms.\r\nts=2019-01-20 21:14:05;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@14dad5dc\r\n    @java.lang.System.gc()\r\n        at com.lz.test.Test.main(Test.java:322)\r\n\r\n```\r\n\r\n首先输入options unsafe true允许我们对jdk增强，然后对System.gc进行进行监视，然后记录当前的堆栈来获取是什么位置进行的调用。\r\n## 7.如何重定义某个类?\r\n有些时候我们找了所有的命令，发现和我们的需求并不符合的时候，那么这个时候我们可以重新定义这个类，我们可以用使用下面的命令。\r\n### 7.1 redefine\r\nredefine命令提供了我们可以重新定义jvm中的class，但是使用这个命令之后class不可恢复。我们首先需要把重写的class编译出来，然后上传到我们指定的目录，进行下面的操作:\r\n```shell\r\n redefine -p /tmp/Test.class\r\n```\r\n\r\n可以重定义我们的Test.class。从而修改逻辑，完成我们自定义的需求。\r\n",
    "readNum": 9,
    "likeNum": 1,
    "cover": null,
    "coverType": 2,
    "createTime": 1552122578000,
    "updateTime": 1551934422000,
    "recommend": false,
    "categoryId": "9,11,12",
    "publish": true,
    "top": false,
    "contentFormat": "<h2 id=\"-arthas-\">性能分析利器《Arthas》总结</h2>\r\n<p>Arthas 是Alibaba开源的Java诊断工具，为什么要介绍这个工具呢？先来看看你是否都遇到这样的场景：</p>\r\n<ul>\r\n<li>当你线上项目出了问题，但是一打开日志发现，有些地方忘记打了日志，于是你马上补上日志，然后重新上线。</li>\r\n<li>当你的项目某个接口执行速度较慢，为了排查问题，于是你四处加上每个方法运行时间。</li>\r\n<li>当你发现某个类有冲突，好像在线上运行的结果和你预期的不符合，手动把线上编译出的class文件下载下来然后反编译，看看究竟class内容是什么。</li>\r\n<li>当你发现系统突然报出某个类的Exception，却无法找到这个类是从哪个Jar包加载的。</li>\r\n<li>当你发现有时候排查一个问题需要上游重复调用这个方法，于是你只能想尽办法利用postman等工具重现这个请求。</li>\r\n</ul>\r\n<p>下面我将会介绍一下Arthas的一些常用的命令和用法，看看是如何解决我们实际中的问题的，至于安装教程可以参考Arthas的github。</p>\r\n<blockquote>\r\n<p><a href=\"https://github.com/alibaba/arthas\">https://github.com/alibaba/arthas</a></p>\r\n</blockquote>\r\n<h2 id=\"-\">常用命令</h2>\r\n<p>dashboard 当前系统的实时数据面板  </p>\r\n<p>jvm 查看当前JVM信息  </p>\r\n<p>thread 可直接查看线程的cpu占用比  </p>\r\n<p>sc sm 快速搜索类和方法信息  </p>\r\n<p>getstatic 查看类静态变量  </p>\r\n<p>jad 反编译class文件  </p>\r\n<p>mc 编译.java文件生成.class  </p>\r\n<p>redefine 加载外部class文件到应用程序中  </p>\r\n<p>monitor 监测方法调用次数、成功次数、失败次数、平均RT等  </p>\r\n<p>watch tt 观测方法执行的前、后、结束、异常、耗时过大时，入参（入参属性深度可调）、返回值、异常，支持实时监测每次方法执行和方法的所有调用执行。  </p>\r\n<p>trace 查看方法调用树耗时  </p>\r\n<p>stack 查看方法的所有调用树路径</p>\r\n<h2 id=\"1-\">1.奇怪的类加载错误</h2>\r\n<p>&emsp;&emsp;相信大家都遇到过NoSuchMethodError这个错误，一般老司机看见这个错误第一反应就是jar包版本号冲突，这种问题一般来说使用maven的一些插件就能轻松解决。  </p>\r\n<p>&emsp;&emsp;之前遇到个奇怪的问题，我们有两个服务的client-jar包，有个类的包名和类名均是一致，在编写代码的时候没有注意到这个问题，在编译阶段由于包名和类名都是一致，所有编译阶段并没有报错，在线下的运行阶段没有问题，但是测试环境的机器中的运行阶段缺报出了问题。这个和之前的jar包版本号冲突有点不同，因为在排查的时候我们想使用A服务的client-jar包的这个类，但是这个jar包的版本号在Maven中的确是唯一的。\r\n这个时候Arthas就可以大显神通了。</p>\r\n<h3 id=\"1-1-sc-\">1.1 sc命令</h3>\r\n<p>找到对应的类，然后输出下面的命令(用例使用的是官方提供的用例):</p>\r\n<pre><code class=\"language-shell\">$ sc -d demo.MathGame\r\nclass-info        demo.MathGame\r\ncode-source       /private/tmp/arthas-demo.jar\r\nname              demo.MathGame\r\nisInterface       false\r\nisAnnotation      false\r\nisEnum            false\r\nisAnonymousClass  false\r\nisArray           false\r\nisLocalClass      false\r\nisMemberClass     false\r\nisPrimitive       false\r\nisSynthetic       false\r\nsimple-name       MathGame\r\nmodifier          public\r\nannotation\r\ninterfaces\r\nsuper-class       +-java.lang.Object\r\nclass-loader      +-sun.misc.Launcher$AppClassLoader@3d4eac69\r\n                    +-sun.misc.Launcher$ExtClassLoader@66350f69\r\nclassLoaderHash   3d4eac69\r\n\r\nAffect(row-cnt:1) cost in 875 ms.\r\n</code></pre>\r\n<p>可以看见打印出了code-source,当时发现了code-source并不是从对应的Jar包取出来的，于是发现了两个服务对于同一个类使用了同样的包名和类名，导致了这个奇怪的问题，后续通过修改包名和类名进行解决。</p>\r\n<h3 id=\"1-2-jad\">1.2 jad</h3>\r\n<p>Arthas还提供了一个命令jad用来反编译,对于解决类冲突错误很有用，比如我们想知道这个类里面的代码到底是什么，直接一个jad命令就能搞定:</p>\r\n<pre><code class=\"language-shell\">$ jad java.lang.String\r\n\r\nClassLoader:\r\n\r\nLocation:\r\n\r\n/*\r\n* Decompiled with CFR 0_132.\r\n*/\r\npackage java.lang;\r\n\r\nimport java.io.ObjectStreamField;\r\n...\r\npublic final class String\r\nimplements Serializable,\r\nComparable&lt;String&gt;,\r\nCharSequence {\r\n    private final char[] value;\r\n    private int hash;\r\n    private static final long serialVersionUID = -6849794470754667710L;\r\n    private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];\r\n    public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator();\r\n\r\n    public String(byte[] arrby, int n, int n2) {\r\n        String.checkBounds(arrby, n, n2);\r\n        this.value = StringCoding.decode(arrby, n, n2);\r\n    }\r\n...</code></pre>\r\n<p>一般通过这个命令我们就能发现和你所期待的类是否缺少了某些方法，或者某些方法有些改变，从而确定jar包冲突。</p>\r\n<h2 id=\"2-\">2.动态修改日志级别</h2>\r\n<p>有很多同学可能会觉得动态修改日志有什么用呢？好像自己也没怎么用过呢？\r\n一般来说下面这几个场景可以需要:  </p>\r\n<p>一般大家日志级别默认是info，有时候需要查看debug的日志可能需要重新上线。\r\n当线上某个应用流量比较大的时候，如何业务出现问题，可能会短时间之内产生大量日志，由于日志会写盘，会消耗大量的内存和磁盘IO进一步加重我们的问题严重性，进而引起雪崩。\r\n我们可以使用动态修改日志解决我们上面两个问题</p>\r\n<h3 id=\"2-1-ognl\">2.1 ognl</h3>\r\n<p>ognl是一门表达式语言，在Arthas中你可以利用这个表达式语言做很多事，比如执行某个方法，获取某个信息。再这里我们可以通过下面的命令来动态的修改日志级别:</p>\r\n<pre><code class=\"language-shell\">$ ognl &#39;@com.lz.test@LOGGER.logger.privateConfig&#39;\r\n@PrivateConfig[\r\n    loggerConfig=@LoggerConfig[root],\r\n    loggerConfigLevel=@Level[INFO],\r\n    intLevel=@Integer[400],\r\n]\r\n$ ognl &#39;@com.lz.test@LOGGER.logger.setLevel(@org.apache.logging.log4j.Level@ERROR)&#39;\r\nnull\r\n$ ognl &#39;@com.lz.test@LOGGER.logger.privateConfig&#39;\r\n@PrivateConfig[\r\n    loggerConfig=@LoggerConfig[root],\r\n    loggerConfigLevel=@Level[ERROR],\r\n    intLevel=@Integer[200],\r\n\r\n]\r\n</code></pre>\r\n<h2 id=\"3-\">3.如何知道某个方法是否调用</h2>\r\n<p>很多时候我们方法执行的情况和我们预期不符合，但是我们又不知道到底哪里不符合，Arthas的watch命令就能帮助我们解决这个问题。</p>\r\n<h3 id=\"3-1-watch\">3.1 watch</h3>\r\n<p>watch命令顾名思义观察，他可以观察指定方法调用情况，定义了4个观察事件点， -b 方法调用前，-e 方法异常后，-s 方法返回后，-f 方法结束后。默认是-f\r\n比如我们想知道某个方法执行的时候，参数和返回值到底是什么。注意这里的参数是方法执行完成的时候的参数，和入参不同有可能会发生变化。</p>\r\n<pre><code class=\"language-shell\">$ watch demo.MathGame primeFactors &quot;{params,returnObj}&quot; -x 2\r\nPress Ctrl+C to abort.\r\nAffect(class-cnt:1 , method-cnt:1) cost in 44 ms.\r\nts=2018-12-03 19:16:51; [cost=1.280502ms] result=@ArrayList[\r\n    @Object[][\r\n        @Integer[535629513],\r\n    ],\r\n    @ArrayList[\r\n        @Integer[3],\r\n        @Integer[19],\r\n        @Integer[191],\r\n        @Integer[49199],\r\n    ],\r\n]</code></pre>\r\n<p>你能得到参数和返回值的情况，以及方法时间消耗的等信息。</p>\r\n<h2 id=\"4-\">4.如何知道某个方法耗时较多</h2>\r\n<p>当某个方法耗时较长，这个时候你需要排查到底是某一处发生了长时间的耗时，一般这种问题比较难排查，都是通过全链路追踪trace图去进行排查，但是在本地的应用中没有trace图，这个时候需要Arthas的trace命令来进行排查问题。</p>\r\n<h3 id=\"4-1-trace\">4.1 trace</h3>\r\n<p>trace 命令能主动搜索 class-pattern／method-pattern 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。\r\n但是trace只能追踪一层的调用链路，如果一层的链路信息不够用，可以把该链路上有问题的方法再次进行trace。\r\ntrace使用例子如下。</p>\r\n<pre><code class=\"language-shell\">$ trace demo.MathGame run\r\nPress Ctrl+C to abort.\r\nAffect(class-cnt:1 , method-cnt:1) cost in 42 ms.\r\n`---ts=2018-12-04 00:44:17;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69\r\n    `---[10.611029ms] demo.MathGame:run()\r\n        +---[0.05638ms] java.util.Random:nextInt()\r\n        +---[10.036885ms] demo.MathGame:primeFactors()\r\n        `---[0.170316ms] demo.MathGame:print()\r\n</code></pre>\r\n<p>可以看见上述耗时最多的方法是primeFactors，所以我们可以对其进行trace进行再一步的排查。</p>\r\n<h2 id=\"5-\">5.如何使用命令重发请求？</h2>\r\n<p>有时候排查一个问题需要上游再次调用这个方法，比如使用postMan等工具，当然Arthas提供了一个命令让替代我们来回手动请求。</p>\r\n<h3 id=\"5-1-tt\">5.1 tt</h3>\r\n<p>tt官方介绍: 方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测。可以看见tt可以用于录制请求，当然也支持我们重放。\r\n如果要录制某个方法，可以用下面命令:</p>\r\n<pre><code class=\"language-shell\">$ tt -t demo.MathGame primeFactors\r\nPress Ctrl+C to abort.\r\nAffect(class-cnt:1 , method-cnt:1) cost in 66 ms.\r\n INDEX   TIMESTAMP            COST(ms)  IS-RET  IS-EXP   OBJECT         CLASS                          METHOD\r\n-------------------------------------------------------------------------------------------------------------------------------------\r\n 1000    2018-12-04 11:15:38  1.096236  false   true     0x4b67cf4d     MathGame                       primeFactors\r\n 1001    2018-12-04 11:15:39  0.191848  false   true     0x4b67cf4d     MathGame                       primeFactors\r\n 1002    2018-12-04 11:15:40  0.069523  false   true     0x4b67cf4d     MathGame                       primeFactors\r\n 1003    2018-12-04 11:15:41  0.186073  false   true     0x4b67cf4d     MathGame                       primeFactors\r\n 1004    2018-12-04 11:15:42  17.76437  true    false    0x4b67cf4d     MathGame                       primeFactors\r\n</code></pre>\r\n<p>上面录制了5个调用环境现场，也可以看做是录制了5个请求返回信息。比如我们想选择index为1004个的请求来重放，可以输入下面的命令。</p>\r\n<pre><code class=\"language-shell\">$ tt -i 1004 -p\r\n RE-INDEX       1004\r\n GMT-REPLAY     2018-12-04 11:26:00\r\n OBJECT         0x4b67cf4d\r\n CLASS          demo.MathGame\r\n METHOD         primeFactors\r\n PARAMETERS[0]  @Integer[946738738]\r\n IS-RETURN      true\r\n IS-EXCEPTION   false\r\n RETURN-OBJ     @ArrayList[\r\n                    @Integer[2],\r\n                    @Integer[11],\r\n                    @Integer[17],\r\n                    @Integer[2531387],\r\n                ]\r\nTime fragment[1004] successfully replayed.\r\nAffect(row-cnt:1) cost in 14 ms.</code></pre>\r\n<p>注意重放请求需要关注两点:</p>\r\n<p>ThreadLocal 信息丢失:由于使用的是Arthas线程调用，会让threadLocal信息丢失，比如一些TraceId信息可能会丢失\r\n引用的对象:保存的入参是保存的引用，而不是拷贝，所以如果参数中的内容被修改，那么入参其实也是被修改的。</p>\r\n<h2 id=\"6-\">6.一些耗时的方法，经常被触发，如何知道谁调用的?</h2>\r\n<p>有时候有些方法非常耗时或者非常重要，需要知道到底是谁发起的调用，比如System.gc(),有时候如果你发现fullgc频繁是因为System.gc()引起的，你需要查看到底是什么应用调用的，那么你就可以使用下面的命令\r\n我们可以输入下面的命令:</p>\r\n<pre><code class=\"language-shell\">$ options unsafe true\r\n NAME    BEFORE-VALUE  AFTER-VALUE                                                                                                                                                                        \r\n-----------------------------------                                                                                                                                                                       \r\n unsafe  false         true                                                                                                                                                                               \r\n$ stack java.lang.System gc\r\nPress Ctrl+C to abort.\r\nAffect(class-cnt:1 , method-cnt:1) cost in 50 ms.\r\nts=2019-01-20 21:14:05;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@14dad5dc\r\n    @java.lang.System.gc()\r\n        at com.lz.test.Test.main(Test.java:322)\r\n</code></pre>\r\n<p>首先输入options unsafe true允许我们对jdk增强，然后对System.gc进行进行监视，然后记录当前的堆栈来获取是什么位置进行的调用。</p>\r\n<h2 id=\"7-\">7.如何重定义某个类?</h2>\r\n<p>有些时候我们找了所有的命令，发现和我们的需求并不符合的时候，那么这个时候我们可以重新定义这个类，我们可以用使用下面的命令。</p>\r\n<h3 id=\"7-1-redefine\">7.1 redefine</h3>\r\n<p>redefine命令提供了我们可以重新定义jvm中的class，但是使用这个命令之后class不可恢复。我们首先需要把重写的class编译出来，然后上传到我们指定的目录，进行下面的操作:</p>\r\n<pre><code class=\"language-shell\"> redefine -p /tmp/Test.class</code></pre>\r\n<p>可以重定义我们的Test.class。从而修改逻辑，完成我们自定义的需求。</p>\r\n",
    "categoryListStr": null,
    "tagList": [
      {
        "id": 10,
        "name": "Arthas",
        "type": 0
      }
    ]
  }
}
